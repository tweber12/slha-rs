// Copyright 2017 Torsten Weber
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! A module containing parts of the internal API that have to be public for them to be usable by
//! the code generated by the `slha-derive` crate.

use {Decay, Line, Parseable, RawBlock, SlhaBlock};
use errors::*;

use std::{iter, result, str};
use std::hash::Hash;
use std::collections::HashMap;

/// A segment read from an SLHA file, i.e. either a block or a decay table.
#[derive(Clone, Debug, PartialEq)]
pub enum Segment<'a> {
    Block { name: String, block: RawBlock<'a> },
    Decay {
        pdg_id: i64,
        width: f64,
        decays: Vec<Decay>,
    },
}

/// A trait for blocks for which `SlhaDeserialize` can be automatically derived.
///
/// This is the trait that the `derive` code uses to read in a block.
/// Therefore, this trait must be implemented by all fields of a struct for which `SlhaDeserialize`
/// is supposed to be derived.
///
/// The reason why this exists is to generalize over the `Option`, `Vec` and plain `SlhaBlock`
/// cases.
pub trait WrappedBlock<E>: Sized {
    type Wrapper: Default;
    fn parse_into<'a>(
        block: &RawBlock<'a>,
        wrapped: &mut Self::Wrapper,
        name: &str,
    ) -> result::Result<(), E>;
    fn unwrap(name: &str, wrapped: Self::Wrapper) -> result::Result<Self, E>;
}

impl<T> WrappedBlock<Error> for T
where
    T: SlhaBlock,
{
    type Wrapper = Option<T>;
    fn parse_into<'a>(block: &RawBlock<'a>, wrapped: &mut Option<T>, name: &str) -> Result<()> {
        match *wrapped {
            None => *wrapped = Some(block.to_block(name)?),

            Some(_) => return Err(ErrorKind::DuplicateBlock(name.to_string()).into()),
        }
        Ok(())
    }
    fn unwrap(name: &str, wrapped: Option<T>) -> Result<T> {
        match wrapped {
            Some(block) => Ok(block),
            None => Err(ErrorKind::MissingBlock(name.to_string()).into()),
        }
    }
}

impl<T> WrappedBlock<Error> for Option<T>
where
    T: SlhaBlock,
{
    type Wrapper = Option<T>;
    fn parse_into<'a>(block: &RawBlock<'a>, wrapped: &mut Option<T>, name: &str) -> Result<()> {
        match *wrapped {
            None => *wrapped = Some(block.to_block(name)?),
            Some(_) => return Err(ErrorKind::DuplicateBlock(name.to_string()).into()),
        }
        Ok(())
    }
    fn unwrap(_: &str, wrapped: Option<T>) -> Result<Option<T>> {
        Ok(wrapped)
    }
}

impl<T> WrappedBlock<Error> for Vec<T>
where
    T: SlhaBlock,
{
    type Wrapper = Vec<T>;
    fn parse_into<'a>(block: &RawBlock<'a>, wrapped: &mut Vec<T>, name: &str) -> Result<()> {
        wrapped.push(block.to_block(name)?);
        Ok(())
    }
    fn unwrap(name: &str, wrapped: Vec<T>) -> Result<Vec<T>> {
        let mut no_scale = false;
        let mut seen = Vec::new();
        for block in &wrapped {
            if let Some(scale) = block.scale() {
                if no_scale {
                    return Err(ErrorKind::RedefinedBlockWithQ(name.to_string()).into());
                }
                if seen.contains(&scale) {
                    return Err(ErrorKind::DuplicateBlockScale(name.to_string(), scale).into());
                }
                seen.push(scale);
            } else {
                if no_scale {
                    bail!(ErrorKind::DuplicateBlock(name.to_string()));
                }
                no_scale = true;
                if !seen.is_empty() {
                    return Err(ErrorKind::RedefinedBlockWithQ(name.to_string()).into());
                }
            }
        }
        Ok(wrapped)
    }
}

/// Parses a segment from an SLHA file, i.e. either a block or a decay table.
pub fn parse_segment<'a>(
    input: &mut iter::Peekable<str::Lines<'a>>,
) -> Option<Result<Segment<'a>>> {
    skip_empty_lines(input);
    match input.next() {
        Some(line) => Some(parse_segment_line(line, input)),
        None => None,
    }
}

fn parse_segment_line<'a>(
    line: &'a str,
    input: &mut iter::Peekable<str::Lines<'a>>,
) -> Result<Segment<'a>> {
    if line.starts_with(|c: char| c.is_whitespace()) {
        bail!(ErrorKind::UnexpectedIdent(line.to_string()));
    }
    match next_word(line) {
        Some((kw, rest)) => match kw.to_lowercase().as_ref() {
            "block" => parse_block(rest, input),
            "decay" => parse_decay_table(rest, input),
            kw => bail!(ErrorKind::UnknownSegment(kw.to_string())),
        },
        None => unreachable!("All empty lines have been skipped, so this line MUST NOT be empty."),
    }
}

fn parse_block<'a, Iter>(header: &'a str, input: &mut iter::Peekable<Iter>) -> Result<Segment<'a>>
where
    Iter: Iterator<Item = &'a str>,
{
    let (header, _) = split_comment(header);
    let (name, extra_header) = match next_word(header) {
        None => bail!(ErrorKind::MissingBlockName),
        Some((name, extra)) => (name.to_lowercase(), extra.trim()),
    };
    let mut lines = Vec::new();
    loop {
        {
            skip_empty_lines(input);
            let line = match input.peek() {
                Some(line) => line,
                None => break,
            };
            if !line.starts_with(|c: char| c.is_whitespace()) {
                break;
            }
            let (data, comment) = split_comment(line.trim());
            lines.push(Line { data, comment });
        }
        input.next();
    }
    Ok(Segment::Block {
        name,
        block: RawBlock { lines, extra_header },
    })
}

/// Parses the body of a block
pub fn parse_block_body<'input, K, V>(lines: &[Line<'input>]) -> Result<HashMap<K, V>>
where
    K: Hash + Eq + Parseable,
    V: Parseable,
{
    parse_block_body_by(lines, parse_line_block)
}

/// Parses the body of a block using a given parser for each line
pub fn parse_block_body_by<'input, K, V>(
    lines: &[Line<'input>],
    line_parser: fn(&str) -> Result<(K, V)>,
) -> Result<HashMap<K, V>>
where
    K: Hash + Eq,
{
    let mut map = HashMap::new();
    for (i, line) in lines.iter().enumerate() {
        let (key, value) = line_parser(line.data).chain_err(|| ErrorKind::InvalidBlockLine(i + 1))?;
        let dup = map.insert(key, value);
        if dup.is_some() {
            bail!(ErrorKind::DuplicateKey(i + 1));
        }
    }
    Ok(map)
}

fn parse_line_block<'input, Key, Value>(input: &'input str) -> Result<(Key, Value)>
where
    Key: Parseable,
    Value: Parseable,
{
    println!("{:?} > {:?}", Key::LENGTH, Value::LENGTH);
    if Key::LENGTH.is_none() {
        return parse_line_block_unsized(input);
    }
    let mut words = input.split_whitespace();
    let key = Key::parse(&mut words).chain_err(|| ErrorKind::InvalidBlockKey)?;
    let value = Value::parse_all(&mut words).chain_err(|| ErrorKind::InvalidBlockValue)?;
    Ok((key, value))
}

fn parse_line_block_unsized<'input, Key, Value>(input: &'input str) -> Result<(Key, Value)>
where
    Key: Parseable,
    Value: Parseable,
{
    if let Some(len) = Value::LENGTH {
        parse_line_block_split(input, len as usize)
    } else {
        let n_words = input.split_whitespace().count();
        for _ in 1..(n_words - 1) {
            let split = parse_line_block_split(input, n_words);
            if split.is_ok() {
                return split;
            }
        }
        bail!(ErrorKind::InvalidBlockValue);
    }
}

fn parse_line_block_split<'input, Key, Value>(
    input: &'input str,
    len_value: usize,
) -> Result<(Key, Value)>
where
    Key: Parseable,
    Value: Parseable,
{
    let words: Vec<_> = input.split_whitespace().collect();
    let start_value = words.len() - len_value as usize;

    let mut words_key = words[..start_value].iter().map(|x| *x);
    let key = Key::parse_all(&mut words_key).chain_err(|| ErrorKind::InvalidBlockKey)?;

    let mut words_value = words[start_value..].iter().map(|x| *x);
    let value = Value::parse_all(&mut words_value).chain_err(|| ErrorKind::InvalidBlockValue)?;

    Ok((key, value))
}

fn parse_decay_table<'a, Iter>(
    header: &str,
    input: &mut iter::Peekable<Iter>,
) -> Result<Segment<'a>>
where
    Iter: Iterator<Item = &'a str>,
{
    let (pdg_id, width) = parse_decay_table_header(header)?;
    let mut decays = Vec::new();
    loop {
        {
            skip_empty_lines(input);
            let line = match input.peek() {
                Some(line) => line,
                None => break,
            };
            if !line.starts_with(|c: char| c.is_whitespace()) {
                break;
            }
            let (data, _) = split_comment(line.trim());
            let n = decays.len() + 1;
            decays.push(parse_decay(data)
                .chain_err(|| ErrorKind::InvalidDecayLine(n))
                .chain_err(|| ErrorKind::InvalidDecay(pdg_id))?);
        }
        input.next();
    }
    Ok(Segment::Decay {
        pdg_id,
        width,
        decays,
    })
}

fn ensure_eol<'input, I>(words: &mut I) -> Result<()>
where
    I: Iterator<Item = &'input str>,
{
    let rest: Vec<_> = words.map(|x| x.to_string()).collect();
    if !rest.is_empty() {
        bail!(ErrorKind::IncompleteParse(rest));
    }
    Ok(())
}

fn parse_decay_table_header(header: &str) -> Result<(i64, f64)> {
    let (data, _) = split_comment(header);
    let mut words = data.split_whitespace();
    let pdg_id = i64::parse(&mut words).chain_err(|| ErrorKind::InvalidDecayingPdgId)?;
    let width = f64::parse_all(&mut words)
        .chain_err(|| ErrorKind::InvalidWidth)
        .chain_err(|| ErrorKind::InvalidDecay(pdg_id))?;
    Ok((pdg_id, width))
}

fn parse_decay(line: &str) -> Result<Decay> {
    let mut words = line.split_whitespace();
    let branching_ratio = f64::parse(&mut words).chain_err(|| ErrorKind::InvalidBranchingRatio)?;
    let n_daughters = u8::parse(&mut words).chain_err(|| ErrorKind::InvalidNumOfDaughters)?;
    let mut daughters = Vec::new();
    for _ in 0..n_daughters {
        let daughter_id = i64::parse(&mut words).chain_err(|| ErrorKind::InvalidDaughterId)?;
        daughters.push(daughter_id);
    }
    ensure_eol(&mut words)?;
    Ok(Decay {
        branching_ratio,
        daughters,
    })
}

fn skip_empty_lines<'a, Iter>(input: &mut iter::Peekable<Iter>)
where
    Iter: Iterator<Item = &'a str>,
{
    loop {
        let line = match input.peek() {
            Some(line) => line.trim(),
            None => break,
        };
        if line.is_empty() || line.starts_with('#') {
            input.next();
        } else {
            break;
        }
    }
}

/// Splits off the first word from a string.
pub fn next_word(input: &str) -> Option<(&str, &str)> {
    let input = input.trim_left();
    if input.is_empty() {
        return None;
    }
    let index = match input.find(|c: char| c.is_whitespace()) {
        Some(index) => index,
        None => return Some((input, "")),
    };
    Some(input.split_at(index))
}

fn split_comment(line: &str) -> (&str, Option<&str>) {
    let start = match line.find('#') {
        None => return (line, None),
        Some(start) => start,
    };
    let (data, comment) = line.split_at(start);
    (data, Some(comment))
}

#[cfg(test)]
mod tests {
    use super::next_word;

    #[test]
    fn test_next_word() {
        assert_eq!(next_word(""), None);
        assert_eq!(next_word("    "), None);
        assert_eq!(next_word("\t \t   "), None);
        assert_eq!(next_word("foo"), Some(("foo", "")));
        assert_eq!(next_word("   bar"), Some(("bar", "")));
        assert_eq!(next_word("foo    "), Some(("foo", "    ")));
        assert_eq!(next_word("   bar\t  "), Some(("bar", "\t  ")));
        assert_eq!(next_word("bar\t  foogh"), Some(("bar", "\t  foogh")));
        assert_eq!(next_word("   bar\t  foogh"), Some(("bar", "\t  foogh")));
        assert_eq!(next_word("\tbar"), Some(("bar", "")));
        assert_eq!(next_word(" \t  bar\t  "), Some(("bar", "\t  ")));
        assert_eq!(next_word("\t   \tbar\t  foogh"), Some(("bar", "\t  foogh")));
    }
}
